/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.2.16 ./public/charater1.glb -o ./src/Character.jsx 
*/

import React, { forwardRef, useEffect, useRef } from 'react'
import { useGLTF, useAnimations, useKeyboardControls, Html } from '@react-three/drei'
import { useControls } from "leva"
import { RigidBody, CapsuleCollider } from '@react-three/rapier'
import { useFrame, useGraph } from '@react-three/fiber';
import { useCallback } from 'react';
import * as THREE from "three";
import "./Chracter.css"
import { SkeletonUtils } from 'three-stdlib';
import { useMemo } from 'react'
const CHARACTER_HEIGH = 1.79;
const CAPSULE_RADIUS = 0.3;

const WALK_SPEED = 1;
const RUN_SPEED = 2;

function ApplyShadow({ refTarget }) {
  useEffect(() => {
    refTarget.current?.traverse((obj) => {
      if (obj.isMesh) {
        obj.castShadow = true;
        obj.receiveShadow = true;
      }
    })
  }, [])
}

function UpdateFrame({ actions, refModel, refRigid, refOrbitControls }) {
  const [/*subscribeKeys*/, getKeys] = useKeyboardControls();
  const refPlayingActionName = useRef();
  const refSpeed = useRef();
  const playAction = (actionName) => {
    if (refPlayingActionName.current === actionName) return;
    const action = actions[actionName];
    const prevAction = actions[refPlayingActionName.current];
    action.reset().fadeIn(0.5).play();
    prevAction?.fadeOut(0.5);
    refPlayingActionName.current = actionName;

  }
  const getDirectionOffset = useCallback((keys) => {
    let directionOffset = 0; // w
    if (keys.forward) {
      if (keys.leftward) {
        directionOffset = Math.PI / 4 // w+a (45)
      } else if (keys.rightward) {
        directionOffset = -Math.PI / 4 // w+d (-45)
      }
    } else if (keys.backward) {
      if (keys.leftward) {
        directionOffset = Math.PI / 4 + Math.PI / 2 // s+a (135)
      } else if (keys.rightward) {
        directionOffset = -Math.PI / 4 - Math.PI / 2 // s+d (-135)
      } else {
        directionOffset = Math.PI // s (180)
      }
    } else if (keys.leftward) {
      directionOffset = Math.PI / 2 // a (90)
    } else if (keys.rightward) {
      directionOffset = -Math.PI / 2 // d (-90)
    }
    return directionOffset
  }, [])

  useFrame((state, delta) => {
    const keys = getKeys();
    if (keys.forward || keys.leftward || keys.rightward || keys.backward) {
      if (keys.walk) {
        playAction("walk");
        refSpeed.current = WALK_SPEED;
      }
      else {
        playAction("run");
        refSpeed.current = RUN_SPEED;
      }
    }
    else {
      playAction("Armature|mixamo.com|Layer0");
      refSpeed.current = 0;
    }
    const camera = state.camera;
    const model = refModel.current;
    const modelPosition = new THREE.Vector3();
    model.getWorldPosition(modelPosition);
    const angleCameraDirectionAxisY = Math.atan2(
      camera.position.x - modelPosition.x,
      camera.position.z - modelPosition.z
    ) + Math.PI;
    const rotateQuarternion = new THREE.Quaternion();
    rotateQuarternion.setFromAxisAngle(new THREE.Vector3(0, 1, 0),
      angleCameraDirectionAxisY + getDirectionOffset(keys));//눌러진 키 방향으로 바라보게 변경 
    model.quaternion.rotateTowards(rotateQuarternion, THREE.MathUtils.degToRad(5));
    //캐릭터 위치 이동
    const walkDirection = new THREE.Vector3();
    camera.getWorldDirection(walkDirection);
    walkDirection.y = 0;
    walkDirection.normalize();
    walkDirection.applyAxisAngle(new THREE.Vector3(0, 1, 0), getDirectionOffset(keys));
    const dx = walkDirection.x * refSpeed.current * delta;
    const dz = walkDirection.z * refSpeed.current * delta;
    if (refRigid.current) {
      const cx = refRigid.current.translation().x + dx;
      const cy = refRigid.current.translation().y;
      const cz = refRigid.current.translation().z + dz;
      // console.log("여기임"+cx,cy,cz)
      refRigid.current.setTranslation({ x: cx, y: cy, z: cz });
      //카메라가 항상 캐릭터를 바라보도록 변경
      camera.position.x += dx;
      camera.position.z += dz;
      if (refOrbitControls.current) {
        refOrbitControls.current.target.set(cx, cy, cz);
      }
    }


  });
}





// export function Character(props) {
function Character({ name="익명", refOrbitControls, ...props }, refRigid) {
  const group = useRef();
  // const refRigid=useRef();
  const { scene, materials, animations } = useGLTF('/charater1.glb')
  const clone=useMemo(()=>SkeletonUtils.clone(scene),[scene])
  const {nodes}=useGraph(clone)
  const { actions } = useAnimations(animations, group)
  //GUI에 애니메이션 이름 표시 (4월 25일 추가함)
  const animationNames = Object.keys(actions);
  const { animationName } = useControls({
    animationName: {
      value: animationNames[0],
      option: animationNames
    }
  })
  console.log(animationNames);

  useEffect(() => {
    const action = actions[animationName];
    action.reset().fadeIn(0.5).play();
    return () => {
      action.fadeOut(0.5);
    }
  }, [animationName])

  return (
    <>
      <RigidBody lockRotations ref={refRigid} colliders={false} {...props}>
        <CapsuleCollider args={[CHARACTER_HEIGH / 2 - CAPSULE_RADIUS, CAPSULE_RADIUS]} />
        <group ref={group} {...props} dispose={null} position-y={-CHARACTER_HEIGH / 2}>
          <group name="Scene">
            <group name="charater" rotation={[Math.PI / 2, 0, 0]} scale={0.01}>
              <primitive object={nodes.mixamorig8Hips} />
              <skinnedMesh name="Ch07_Body001" geometry={nodes.Ch07_Body001.geometry} material={materials['Ch07_body.001']} skeleton={nodes.Ch07_Body001.skeleton} />
              <skinnedMesh name="Ch07_Eyelashes001" geometry={nodes.Ch07_Eyelashes001.geometry} material={materials['Ch07_hair.001']} skeleton={nodes.Ch07_Eyelashes001.skeleton} />
              <skinnedMesh name="Ch07_Hair001" geometry={nodes.Ch07_Hair001.geometry} material={materials['Ch07_hair.001']} skeleton={nodes.Ch07_Hair001.skeleton} />
              <skinnedMesh name="Ch07_Heels001" geometry={nodes.Ch07_Heels001.geometry} material={materials['Ch07_body.001']} skeleton={nodes.Ch07_Heels001.skeleton} />
              <skinnedMesh name="Ch07_Pants001" geometry={nodes.Ch07_Pants001.geometry} material={materials['Ch07_body.001']} skeleton={nodes.Ch07_Pants001.skeleton} />
              <skinnedMesh name="Ch07_Shirt001" geometry={nodes.Ch07_Shirt001.geometry} material={materials['Ch07_body.001']} skeleton={nodes.Ch07_Shirt001.skeleton} />
              <skinnedMesh name="Ch07_Suit001" geometry={nodes.Ch07_Suit001.geometry} material={materials['Ch07_body.001']} skeleton={nodes.Ch07_Suit001.skeleton} />
            </group>
          </group>
        </group>
        <Html wrapperClass='character-name'
        position-y={CHARACTER_HEIGH+CHARACTER_HEIGH/13} center>{name}</Html>
      </RigidBody>
      <ApplyShadow refTarget={group} />
      <UpdateFrame actions={actions} refModel={group} refRigid={refRigid} refOrbitControls={refOrbitControls} />
    </>
  )
}
export default React.forwardRef(Character)
useGLTF.preload('/charater1.glb')
